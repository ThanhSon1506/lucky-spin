<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>V√íNG QUAY N·ªÆ TH·∫¶N</title>

    <style>
        :root {
            --text: #fff6fb;
            --muted: rgba(255, 246, 251, .72);

            --pink-1: #ff77b7;
            --pink-2: #ff4aa2;
            --magenta-1: #b02764;
            --magenta-2: #7a0f43;

            --tet-gold-1: #ffe1b5;
            --tet-gold-2: #ffbf6a;

            --glass: rgba(255, 255, 255, .10);
            --glass2: rgba(255, 255, 255, .06);
            --shadow: rgba(0, 0, 0, .35);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;


            background:
                radial-gradient(900px 520px at 50% 42%,
                    rgba(255, 170, 215, .46) 0%,
                    rgba(255, 120, 190, .22) 15%,
                    rgba(0, 0, 0, 0) 70%),

                radial-gradient(980px 620px at 50% 88%,
                    rgba(255, 206, 232, .40) 0%,
                    rgba(255, 190, 225, .18) 40%,
                    rgba(0, 0, 0, 0) 72%),

                linear-gradient(180deg,
                    rgba(188, 46, 106, .92) 0%,
                    rgba(132, 18, 76, .92) 30%,
                    rgba(92, 6, 50, .94) 100%),

                url("images/theme.png");

            background-size: cover;
            background-position: bottom;
            background-attachment: fixed;
            overflow-x: hidden;
        }

        /* bokeh overlay + vignette ƒë·ªÉ gi·ªëng ·∫£nh m·∫´u h∆°n */
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, .16) 0 60px, rgba(0, 0, 0, 0) 62px),
                radial-gradient(circle at 55% 20%, rgba(255, 255, 255, .12) 0 80px, rgba(0, 0, 0, 0) 82px),
                radial-gradient(circle at 80% 35%, rgba(255, 255, 255, .10) 0 65px, rgba(0, 0, 0, 0) 67px),
                radial-gradient(circle at 30% 75%, rgba(255, 255, 255, .10) 0 95px, rgba(0, 0, 0, 0) 97px),
                radial-gradient(circle at 75% 75%, rgba(255, 255, 255, .10) 0 120px, rgba(0, 0, 0, 0) 122px),
                radial-gradient(1200px 800px at 50% 50%, rgba(0, 0, 0, .10), rgba(0, 0, 0, .35));
            filter: blur(1px);
            opacity: .65;
            mix-blend-mode: screen;
        }

        /* overlay ph√°o hoa */
        #fxCanvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            pointer-events: none;
            z-index: 9999;
        }

        .app {
            width: min(1250px, 100%);
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 18px;
            position: relative;
            z-index: 2;
        }

        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 18px;
            box-shadow: 0 12px 40px var(--shadow);
            overflow: hidden;
            backdrop-filter: blur(8px);
        }

        .hd {
            padding: 16px 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .title {
            font-weight: 900;
            letter-spacing: .2px;
        }

        .sub {
            color: var(--muted);
            font-size: 13px;
            margin-top: 4px;
        }

        .bd {
            padding: 16px 18px;
        }

        .wheelWrap {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 0 10px;
            border-radius: 16px;
            background: url("images/bg-8.3-3.png");
            background-position: top;
            background-size: cover;
            /* th√™m glow ƒë·ªè/v√†ng cho khu v·ª±c v√≤ng quay */
            /* background:
        radial-gradient(500px 320px at 50% 25%, rgba(255, 200, 120, .18), rgba(0, 0, 0, 0) 60%),
        radial-gradient(560px 380px at 50% 70%, rgba(255, 70, 70, .16), rgba(0, 0, 0, 0) 62%); */
        }

        canvas#wheel {
            width: min(560px, 92vw);
            height: auto;
            aspect-ratio: 1/1;
            border-radius: 999px;
            box-shadow:
                inset 0 0 0 10px rgba(0, 0, 0, 0.22),
                0 20px 50px rgba(0, 0, 0, 0.45);
        }

        .pointer {
            position: absolute;
            top: 6px;
            width: 0;
            height: 0;
            border-left: 18px solid transparent;
            border-right: 18px solid transparent;
            border-top: 34px solid var(--tet-gold-2);
            filter: drop-shadow(0 6px 10px rgba(0, 0, 0, .35));
            z-index: 3;
        }

        .center {
            position: absolute;
            width: 130px;
            height: 130px;
            border-radius: 999px;
            background:
                radial-gradient(circle at 30% 30%, rgba(255, 220, 160, 0.24), rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.18);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            pointer-events: auto;
            cursor: pointer;
            text-align: center;
            padding: 10px;
            z-index: 2;
        }

        .center .big {
            font-size: 26px;
            font-weight: 950;
            line-height: 1.1;
        }

        .center .small {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        .controls {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }

        /* ===== N√öT ‚ÄúT·∫æT VUI V·∫∫‚Äù ===== */
        .btn {
            appearance: none;
            border: none;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 14px;
            font-weight: 950;
            letter-spacing: .3px;
            color: #2a0909;
            background: linear-gradient(135deg, var(--tet-gold-1), var(--tet-gold-2));
            box-shadow: 0 12px 28px rgba(255, 179, 0, .20), 0 8px 20px rgba(0, 0, 0, .22);
            transition: transform .08s ease, filter .15s ease, opacity .15s ease;
            user-select: none;
            white-space: nowrap;
            position: relative;
            overflow: hidden;
        }

        .btn::after {
            content: "";
            position: absolute;
            top: -60%;
            left: -40%;
            width: 40%;
            height: 220%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .55), rgba(255, 255, 255, 0));
            transform: rotate(25deg);
            opacity: .55;
            animation: shine 2.8s ease-in-out infinite;
        }

        @keyframes shine {
            0% {
                transform: translateX(-160%) rotate(25deg);
                opacity: 0;
            }

            15% {
                opacity: .6;
            }

            45% {
                transform: translateX(340%) rotate(25deg);
                opacity: .25;
            }

            100% {
                opacity: 0;
            }
        }

        .btn:active {
            transform: translateY(1px) scale(.99);
        }

        .btn.secondary {
            color: var(--text);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.08));
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: none;
            font-weight: 850;
        }

        .btn.secondary::after {
            display: none;
        }

        .btn.danger {
            color: white;
            background: linear-gradient(135deg, var(--magenta-2), var(--magenta-1));
            box-shadow: 0 12px 28px rgba(255, 31, 31, .18), 0 8px 20px rgba(0, 0, 0, .22);
        }

        .btn:disabled {
            opacity: .55;
            cursor: not-allowed;
            filter: saturate(.7);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.14);
            color: var(--muted);
            font-size: 13px;
            white-space: nowrap;
        }

        label {
            color: var(--muted);
            font-size: 13px;
        }

        input[type="number"] {
            width: 120px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(0, 0, 0, 0.25);
            color: var(--text);
            outline: none;
        }

        .resultBox {
            display: grid;
            gap: 10px;
        }

        .result {
            padding: 14px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.18);
        }

        .result .k {
            color: var(--muted);
            font-size: 12px;
        }

        .result .v {
            font-size: 34px;
            font-weight: 950;
            margin-top: 2px;
        }

        .hint {
            color: var(--muted);
            font-size: 13px;
            line-height: 1.45;
        }

        .history {
            max-height: 360px;
            overflow: auto;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.14);
        }

        .history table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .history th,
        .history td {
            padding: 10px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            text-align: left;
            color: var(--text);
        }

        .history th {
            color: var(--muted);
            font-weight: 750;
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.22);
            backdrop-filter: blur(8px);
        }

        .history td.num {
            font-weight: 950;
        }

        .badge {
            display: inline-flex;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(255, 255, 255, 0.06);
            color: var(--muted);
            font-size: 12px;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        /* ===== Number Strip (d·∫£i s·ªë ch·∫°y) ===== */
        .stripWrap {
            margin-top: 6px;
            padding: 12px 12px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.14);
        }

        .stripTitle {
            color: var(--muted);
            font-size: 12px;
            margin-bottom: 10px;
        }

        .strip {
            display: flex;
            gap: 8px;
            overflow: hidden;
            align-items: center;
            justify-content: center;
            padding: 6px 2px;
        }

        .strip .cell {
            min-width: 62px;
            text-align: center;
            padding: 10px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            font-weight: 950;
            font-size: 16px;
            color: rgba(255, 244, 230, 0.92);
            transform: scale(0.95);
            opacity: 0.85;
        }

        .strip .cell.active {
            background: linear-gradient(135deg, rgba(255, 211, 106, 0.28), rgba(255, 31, 31, 0.20));
            border-color: rgba(255, 255, 255, 0.22);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
            transform: scale(1.08);
            opacity: 1;
        }

        .strip .cell.edge {
            opacity: 0.55;
            transform: scale(0.90);
        }

        .itemsInput {
            width: 100%;
            padding: 12px 12px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(0, 0, 0, 0.22);
            color: var(--text);
            outline: none;
            resize: vertical;
            line-height: 1.35;
        }

        .itemsInput:focus {
            border-color: rgba(255, 255, 255, 0.24);
        }

        /* ===== Modal ===== */
        .modal {
            position: fixed;
            inset: 0;
            display: none;
            z-index: 9000;
            /* fxCanvas s·∫Ω ƒë·∫∑t cao h∆°n ƒë·ªÉ ph√°o hoa ƒë√® l√™n modal */
        }

        .modal.show {
            display: block;
        }

        .modal__backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, .55);
            backdrop-filter: blur(6px);
        }

        .modal__panel {
            position: absolute;
            left: 50%;
            top: 50%;
            width: min(560px, 92vw);
            transform: translate(-50%, -50%);
            border-radius: 18px;
            border: 1px solid rgba(255, 255, 255, .16);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
            box-shadow: 0 18px 60px rgba(0, 0, 0, .45);
            overflow: hidden;
        }

        .modal__x {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 36px;
            height: 36px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: rgba(0, 0, 0, .22);
            color: var(--text);
            cursor: pointer;
        }

        .modal__head {
            padding: 16px 18px;
            border-bottom: 1px solid rgba(255, 255, 255, .14);
        }

        .modal__hint {
            color: var(--muted);
            font-size: 14px;
            font-weight: 650;
        }

        .modal__body {
            padding: 22px 18px 12px;
            text-align: center;
        }

        .modal__icon {
            font-size: 30px;
            margin-bottom: 8px;
        }

        .modal__title {
            font-size: 40px;
            font-weight: 950;
            letter-spacing: .5px;
            color: var(--pink-1);
            text-transform: uppercase;
        }

        .modal__actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            padding: 14px 18px 18px;
            border-top: 1px solid rgba(255, 255, 255, .14);
        }

        .center {
            transition: transform .15s ease, box-shadow .2s ease;
        }

        .center:hover {
            transform: scale(1.06);
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
        }

        .center:active {
            transform: scale(0.96);
        }

        .center.disabled {
            opacity: .6;
            cursor: not-allowed;
            transform: none !important;
        }

        .hidden {
            display: none !important;
        }

        /* Settings modal nh·ªè g·ªçn */
        .settingsRow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, .10);
        }

        .settingsRow:last-child {
            border-bottom: none;
        }

        .settingsRow label {
            color: var(--text);
            font-size: 14px;
            font-weight: 750;
        }

        .toggle {
            width: 44px;
            height: 26px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .18);
            background: rgba(0, 0, 0, .22);
            position: relative;
            cursor: pointer;
            flex: 0 0 auto;
        }

        .toggle input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
        }

        .toggle::after {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            border-radius: 999px;
            background: linear-gradient(135deg, var(--tet-gold-1), var(--tet-gold-2));
            transition: transform .18s ease;
        }

        .toggle.on::after {
            transform: translateX(18px);
        }
    </style>
</head>

<body>
    <!-- FX ph√°o hoa -->
    <canvas id="fxCanvas"></canvas>

    <div class="app">
        <!-- LEFT: WHEEL -->
        <div class="card">
            <div class="hd">
                <div>
                    <div class="title">V√≤ng xoay may m·∫Øn</div>
                    <div class="sub">Quay th·ª≠ th√°ch 8.3 (kh√¥ng l·∫∑p n·∫øu b·∫°n ch·ªçn ‚Äúx√≥a‚Äù)</div>
                </div>

                <div class="row" style="justify-content:flex-end; gap:10px;">
                    <div class="pill" id="statusPill">S·∫µn s√†ng</div>
                    <button class="pill" id="settingsBtn" type="button">‚öôÔ∏è</button>

                </div>
            </div>
            <div class="bd">
                <div class="wheelWrap">
                    <div class="pointer" aria-hidden="true"></div>
                    <canvas id="wheel" width="900" height="900"></canvas>
                    <div class="center" id="centerSpinBtn">
                        <div class="big" id="centerNumber">QUAY</div>
                        <div class="small" id="centerText">Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                    </div>
                </div>

                <div class="stripWrap" aria-live="polite">
                    <div class="stripTitle">D·∫£i th·ª≠ th√°ch ƒëang ch·∫°y</div>
                    <div class="strip" id="strip"></div>
                </div>

                <div class="controls">
                    <div class="row">
                        <button class="btn" id="spinBtn">QUAY üéá</button>
                        <button class="btn secondary" id="pickBtn">B·ªêC NG·∫™U NHI√äN üéÅ</button>
                    </div>

                    <div class="row">
                        <!-- <div class="pill">
                            <label for="min">Min</label>
                            <input id="min" type="number" value="1" min="1" max="1600" step="1" />
                            <span class="badge">‚Üî</span>
                            <label for="max">Max</label>
                            <input id="max" type="number" value="1600" min="1" max="1600" step="1" />
                        </div> -->
                        <button class="btn danger" id="resetBtn">RESET üß®</button>
                    </div>

                    <div class="hint">
                        - <b>QUAY</b>: animation gi·∫£m t·ªëc + d·ª´ng ƒë√∫ng s·ªë.<br />
                        - <b>B·ªêC</b>: ra s·ªë ngay (kh√¥ng animation).<br />
                        - L∆∞u l·ªãch s·ª≠ b√™n ph·∫£i.
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT: RESULT + HISTORY -->
        <div class="card">
            <div class="hd">
                <div>
                    <div class="title">K·∫øt qu·∫£ & L·ªãch s·ª≠</div>
                    <div class="sub">M·ªói l·∫ßn quay/b·ªëc s·∫Ω l∆∞u l·∫°i</div>
                </div>
                <div class="pill"><span class="badge">T·ªïng</span> <span id="count">0</span></div>
            </div>

            <div class="bd resultBox">
                <div class="result">
                    <div class="k">K·∫øt qu·∫£ g·∫ßn nh·∫•t</div>
                    <div class="v" id="lastResult">‚Äî</div>
                    <div id="itemsPanel">
                        <div class="k">Danh s√°ch th·ª≠ th√°ch (m·ªói d√≤ng = 1 m·ª•c)</div>

                        <textarea id="itemsInput" rows="9" class="itemsInput"
                            placeholder="M·ªói d√≤ng l√† 1 th·ª≠ th√°ch..."></textarea>

                        <div class="row" style="margin-top:10px;">
                            <button class="btn secondary" id="loadDefaultBtn">N·∫°p m·∫∑c ƒë·ªãnh</button>
                            <button class="btn" id="saveItemsBtn">L∆∞u danh s√°ch</button>
                        </div>

                        <div class="hint" style="margin-top:8px;">
                            L∆∞u xong s·∫Ω thay pool hi·ªán t·∫°i. L·ªãch s·ª≠ kh√¥ng b·ªã x√≥a (RESET m·ªõi x√≥a l·ªãch s·ª≠).
                        </div>
                    </div>
                </div>

                <div class="history" id="historyBox">
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>N·ªôi dung</th>
                                <th>Ki·ªÉu</th>
                                <th>Th·ªùi gian</th>
                            </tr>
                        </thead>
                        <tbody id="historyBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- RESULT MODAL -->
    <div class="modal" id="resultModal" aria-hidden="true">
        <div class="modal__backdrop" data-close="1"></div>

        <div class="modal__panel" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
            <button class="modal__x" type="button" data-close="1" aria-label="ƒê√≥ng">‚úï</button>

            <div class="modal__head">
                <div class="modal__hint">B·∫°n ƒë√£ quay v√†o √¥</div>
            </div>

            <div class="modal__body">
                <div class="modal__icon"></div>
                <div class="modal__title" id="modalTitle">‚Äî</div>
            </div>

            <div class="modal__actions">
                <button class="btn danger" id="modalRemoveBtn">X√≥a √¥ n√†y</button>
                <button class="btn secondary" id="modalCloseBtn">ƒê√≥ng l·∫°i</button>
            </div>
        </div>
    </div>
    <div class="modal" id="settingsModal" aria-hidden="true">
        <div class="modal__backdrop" data-close-settings="1"></div>

        <div class="modal__panel" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
            <button class="modal__x" type="button" data-close-settings="1" aria-label="ƒê√≥ng">‚úï</button>

            <div class="modal__head">
                <div class="title" id="settingsTitle">C√†i ƒë·∫∑t hi·ªÉn th·ªã</div>
                <div class="sub">B·∫≠t/t·∫Øt c√°c khu v·ª±c giao di·ªán</div>
            </div>

            <div class="modal__body" style="text-align:left;">
                <div class="settingsRow">
                    <label for="toggleStrip">Hi·ªán ‚ÄúD·∫£i th·ª≠ th√°ch ƒëang ch·∫°y‚Äù</label>
                    <div class="toggle" id="toggleStripWrap">
                        <input type="checkbox" id="toggleStrip" />
                    </div>
                </div>

                <div class="settingsRow">
                    <label for="toggleItems">Hi·ªán ‚ÄúDanh s√°ch th·ª≠ th√°ch‚Äù</label>
                    <div class="toggle" id="toggleItemsWrap">
                        <input type="checkbox" id="toggleItems" />
                    </div>
                </div>
            </div>

            <div class="modal__actions">
                <button class="btn secondary" id="settingsCloseBtn" type="button">ƒê√≥ng</button>
            </div>
        </div>
    </div>
    <script>
        (() => {
            const $ = (id) => document.getElementById(id);

            function secureRandomInt(min, max) {
                min = Math.ceil(min); max = Math.floor(max);
                if (max < min) [min, max] = [max, min];
                const range = max - min + 1;
                if (range <= 0) return min;

                if (window.crypto && crypto.getRandomValues) {
                    const maxUint = 0xFFFFFFFF;
                    const limit = Math.floor(maxUint / range) * range;
                    const buf = new Uint32Array(1);
                    let x;
                    do { crypto.getRandomValues(buf); x = buf[0]; } while (x >= limit);
                    return min + (x % range);
                }
                return min + Math.floor(Math.random() * range);
            }

            function fmtTime(d) {
                const pad = (n) => String(n).padStart(2, "0");
                return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
            }

            function escapeHtml(s) {
                return String(s)
                    .replaceAll("&", "&amp;")
                    .replaceAll("<", "&lt;")
                    .replaceAll(">", "&gt;")
                    .replaceAll('"', "&quot;")
                    .replaceAll("'", "&#039;");
            }

            function normalizeItems(lines) {
                const out = [];
                const seen = new Set();
                for (const raw of lines) {
                    const s = String(raw ?? "").trim();
                    if (!s) continue;
                    const key = s.toLowerCase();
                    if (seen.has(key)) continue;
                    seen.add(key);
                    out.push(s);
                }
                return out;
            }

            function shorten(s, max = 18) {
                s = String(s ?? "").trim();
                if (s.length <= max) return s;
                return s.slice(0, Math.max(0, max - 1)) + "‚Ä¶";
            }

            function splitWords(text) {
                return String(text ?? "").trim().split(/\s+/).filter(Boolean);
            }

            function wrapByWidth(ctx, text, maxWidth) {
                const words = splitWords(text);
                const lines = [];
                let line = "";

                for (const w of words) {
                    const test = line ? line + " " + w : w;
                    if (ctx.measureText(test).width <= maxWidth) {
                        line = test;
                    } else {
                        if (line) lines.push(line);

                        // 1 t·ª´ qu√° d√†i -> c·∫Øt th√¥
                        if (ctx.measureText(w).width > maxWidth) {
                            let acc = "";
                            for (const ch of Array.from(w)) {
                                const t = acc + ch;
                                if (ctx.measureText(t + "‚Ä¶").width > maxWidth) break;
                                acc = t;
                            }
                            lines.push(acc + "‚Ä¶");
                            line = "";
                        } else {
                            line = w;
                        }
                    }
                }
                if (line) lines.push(line);
                return lines;
            }

            // ===== DOM =====
            const canvas = $("wheel");
            const ctx = canvas.getContext("2d");

            const spinBtn = $("spinBtn");
            const pickBtn = $("pickBtn");
            const resetBtn = $("resetBtn");

            const statusPill = $("statusPill");
            const centerNumber = $("centerNumber");
            const centerText = $("centerText");
            const lastResult = $("lastResult");
            const historyBody = $("historyBody");
            const countEl = $("count");
            const stripEl = $("strip");

            const itemsInput = $("itemsInput");
            const saveItemsBtn = $("saveItemsBtn");
            const loadDefaultBtn = $("loadDefaultBtn");

            // ===== MODAL =====
            const resultModal = $("resultModal");
            const modalTitle = $("modalTitle");
            const modalRemoveBtn = $("modalRemoveBtn");
            const modalCloseBtn = $("modalCloseBtn");

            let pendingPickedText = null;

            // ===== AUDIO =====
            const spinSound = new Audio("sounds/spin.mp3");
            spinSound.loop = true;
            spinSound.volume = 0.65;

            const winSound = new Audio("sounds/win.mp3");
            winSound.volume = 0.95;

            const fireworkSound = new Audio("sounds/firework.mp3");
            fireworkSound.volume = 0.85;

            function startSpinSound() {
                try { spinSound.currentTime = 0; spinSound.play().catch(() => { }); } catch { }
            }
            function stopSpinSound() {
                try { spinSound.pause(); spinSound.currentTime = 0; } catch { }
            }
            function playWinSound() {
                try { winSound.currentTime = 0; winSound.play().catch(() => { }); } catch { }
            }

            function openResultModal(text) {
                pendingPickedText = text;
                if (modalTitle) modalTitle.textContent = text || "‚Äî";
                if (resultModal) {
                    resultModal.classList.add("show");
                    resultModal.setAttribute("aria-hidden", "false");
                }
                celebrate();
            }
            function closeResultModal() {
                pendingPickedText = null;
                if (resultModal) {
                    resultModal.classList.remove("show");
                    resultModal.setAttribute("aria-hidden", "true");
                }
            }
            // ===== SETTINGS =====
            const settingsBtn = $("settingsBtn");
            const settingsModal = $("settingsModal");
            const settingsCloseBtn = $("settingsCloseBtn");

            const toggleStrip = $("toggleStrip");
            const toggleItems = $("toggleItems");

            const toggleStripWrap = $("toggleStripWrap");
            const toggleItemsWrap = $("toggleItemsWrap");

            const stripWrap = document.querySelector(".stripWrap");
            const itemsPanel = $("itemsPanel");

            const UI_PREF_KEY = "wheel_83_ui_prefs_v1";

            function openSettings() {
                if (!settingsModal) return;
                settingsModal.classList.add("show");
                settingsModal.setAttribute("aria-hidden", "false");
            }
            function closeSettings() {
                if (!settingsModal) return;
                settingsModal.classList.remove("show");
                settingsModal.setAttribute("aria-hidden", "true");
            }

            function setToggleUI(wrapEl, checked) {
                if (!wrapEl) return;
                wrapEl.classList.toggle("on", !!checked);
            }

            function applyPrefs(prefs) {
                const showStrip = prefs?.showStrip ?? true;
                const showItems = prefs?.showItems ?? true;

                if (stripWrap) stripWrap.classList.toggle("hidden", !showStrip);
                if (itemsPanel) itemsPanel.classList.toggle("hidden", !showItems);

                if (toggleStrip) toggleStrip.checked = !!showStrip;
                if (toggleItems) toggleItems.checked = !!showItems;

                setToggleUI(toggleStripWrap, showStrip);
                setToggleUI(toggleItemsWrap, showItems);
            }

            function loadPrefs() {
                try {
                    const raw = localStorage.getItem(UI_PREF_KEY);
                    if (raw) return JSON.parse(raw);
                } catch { }
                return { showStrip: true, showItems: true };
            }

            function savePrefs(prefs) {
                try { localStorage.setItem(UI_PREF_KEY, JSON.stringify(prefs)); } catch { }
            }
            // ===== Items =====
            const DEFAULT_ITEMS = [
                "M·ªùi t·∫•t c·∫£ c√πng n√¢ng ly ü•Ç",
                "M·ªùi b√†n b√™n c·∫°nh 1 ly",
                "H√°t 1 c√¢u b·∫•t k·ª≥ üé§",
                "Tha cho m√¨nh ‚Äì ch·ªâ ƒë·ªãnh ng∆∞·ªùi kh√°c üòÜ",
                "T·∫°o d√°ng catwalk 1 v√≤ng üëó",
                "C·∫°n 50% ly hi·ªán t·∫°i",
                "G·ª≠i 1 l·ªùi ch√∫c 8/3 cho t·∫•t c·∫£",
                "K·ªÉ 1 k·ª∑ ni·ªám vui ·ªü c√¥ng ty",
                "Ch·ªâ ƒë·ªãnh 1 ng∆∞·ªùi u·ªëng c√πng",
                "ƒê∆∞·ª£c b·ªè qua th·ª≠ th√°ch"
            ];

            const ITEMS_KEY = "wheel_83_available_items_v1";
            const HISTORY_KEY = "wheel_83_history_v1";

            let availableItems = [];
            let history = [];

            function setTextareaFromList(list) {
                if (!itemsInput) return;
                itemsInput.value = (list || []).join("\n");
            }

            function saveItems() {
                try { localStorage.setItem(ITEMS_KEY, JSON.stringify(availableItems)); } catch { }
            }

            function loadItems() {
                try {
                    const raw = localStorage.getItem(ITEMS_KEY);
                    if (raw) {
                        const arr = JSON.parse(raw);
                        if (Array.isArray(arr) && arr.length) {
                            availableItems = arr.map(String);
                            setTextareaFromList(availableItems);
                            return;
                        }
                    }
                } catch { }

                availableItems = [...DEFAULT_ITEMS];
                saveItems();
                setTextareaFromList(availableItems);
            }

            function saveHistory() {
                try { localStorage.setItem(HISTORY_KEY, JSON.stringify(history)); } catch { }
            }
            function loadHistory() {
                try {
                    const raw = localStorage.getItem(HISTORY_KEY);
                    if (raw) history = JSON.parse(raw) || [];
                } catch { history = []; }
            }

            function pushHistory(text, type) {
                history.unshift({ text, type, t: Date.now() });
                if (history.length > 200) history.length = 200;
                saveHistory();
                renderHistory();
            }

            function renderHistory() {
                historyBody.innerHTML = history.map((h, idx) => {
                    const d = new Date(h.t);
                    return `
        <tr>
          <td>${history.length - idx}</td>
          <td class="num">${escapeHtml(h.text)}</td>
          <td><span class="badge">${escapeHtml(h.type)}</span></td>
          <td class="mono">${fmtTime(d)}</td>
        </tr>
      `;
                }).join("");

                countEl.textContent = String(history.length);
                if (lastResult) lastResult.textContent = history[0]?.text ?? "‚Äî";
            }

            // ===== Wheel drawing =====
            let isSpinning = false;
            let angle = 0;

            const W = canvas.width, H = canvas.height;
            const cx = W / 2, cy = H / 2;
            const radius = Math.min(W, H) * 0.46;

            function getSlices() {
                return Math.max(1, availableItems.length);
            }

            function drawWheel() {
                ctx.clearRect(0, 0, W, H);

                const SLICES = getSlices();
                const sliceAngle = (Math.PI * 2) / SLICES;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);

                const rOuter = radius * 0.98;

                // V√≤ng tr√≤n gi·ªØa (v·∫´n gi·ªØ nh∆∞ b·∫°n ƒëang d√πng)
                const innerRingRadius = radius * 0.32;

                // ‚úÖ CLIP donut: ch·ªØ ch·ªâ ƒë∆∞·ª£c v·∫Ω t·ª´ rInner -> rOuter
                const rInner = innerRingRadius;
                const padAng = sliceAngle * 0.01;

                for (let i = 0; i < SLICES; i++) {
                    const a0 = i * sliceAngle;
                    const a1 = (i + 1) * sliceAngle;
                    const mid = (a0 + a1) / 2;

                    // ===== SLICE =====
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius, a0, a1);
                    ctx.closePath();

                    const alt = i % 2;
                    ctx.fillStyle = alt ? "rgba(255, 211, 106, 0.32)" : "rgba(255, 60, 60, 0.24)";
                    ctx.fill();

                    ctx.strokeStyle = "rgba(255,255,255,0.14)";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // ===== CLIP DONUT =====
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(0, 0, rOuter, a0 + padAng, a1 - padAng);
                    ctx.arc(0, 0, rInner, a1 - padAng, a0 + padAng, true);
                    ctx.closePath();
                    ctx.clip();

                    // ===== TEXT (radial + wrap) =====
                    const text = String(availableItems[i] ?? "")
                        .replace(/\s*\r?\n\s*/g, " ")
                        .trim();

                    if (text) {
                        ctx.save();
                        ctx.rotate(mid);

                        // Upright (flip 1 l·∫ßn)
                        const flip = Math.cos(mid) < 0;
                        if (flip) ctx.rotate(Math.PI);

                        const baseFont = Math.max(12, Math.min(18, 520 / Math.max(6, SLICES)));
                        let fontSize = baseFont;

                        ctx.fillStyle = "rgba(255,244,230,0.92)";
                        ctx.textBaseline = "middle";

                        const rStart = rInner + 14;   // b·∫Øt ƒë·∫ßu ch·ªØ t·ª´ ngo√†i v√πng clip
                        const rEnd = rOuter - 14;

                        // ‚úÖ width theo h∆∞·ªõng radial
                        const maxLineWidth = Math.max(140, rEnd - rStart);

                        ctx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

                        let lines = wrapByWidth(ctx, text, maxLineWidth);
                        const maxLines = SLICES >= 12 ? 3 : 4;

                        // N·∫øu nhi·ªÅu d√≤ng qu√° -> gi·∫£m font r·ªìi wrap l·∫°i
                        while (lines.length > maxLines && fontSize > 11) {
                            fontSize -= 1;
                            ctx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
                            lines = wrapByWidth(ctx, text, maxLineWidth);
                        }

                        // C·∫Øt b·ªõt + ‚Ä¶
                        if (lines.length > maxLines) {
                            lines = lines.slice(0, maxLines);
                            let last = lines[lines.length - 1];
                            while (last.length > 0 && ctx.measureText(last + "‚Ä¶").width > maxLineWidth) {
                                last = last.slice(0, -1);
                            }
                            lines[lines.length - 1] = last + "‚Ä¶";
                        }

                        const lineGap = Math.max(3, Math.round(fontSize * 0.35));
                        const lineH = fontSize + lineGap;
                        const blockH = lines.length * lineH;

                        let y = -(blockH / 2) + lineH / 2;

                        // ‚úÖ FIX: flip -> v·∫Ω v·ªÅ ph√≠a X √¢m + canh ph·∫£i (tr√°nh ‚Äúm·∫•t n·ª≠a b√™n trong‚Äù)
                        const x = flip ? -rStart : rStart;
                        ctx.textAlign = flip ? "right" : "left";

                        for (const ln of lines) {
                            ctx.fillText(ln, x, y);
                            y += lineH;
                        }

                        ctx.restore();
                    }
                    ctx.restore(); // clip
                }

                // highlight overlay
                const grd = ctx.createRadialGradient(
                    -radius * 0.25, -radius * 0.25, radius * 0.05,
                    0, 0, radius
                );
                grd.addColorStop(0, "rgba(255,255,255,0.22)");
                grd.addColorStop(0.45, "rgba(255,255,255,0.06)");
                grd.addColorStop(1, "rgba(255,255,255,0.00)");
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.restore();

                // hub
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.06, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255,255,255,0.12)";
                ctx.fill();
            }
            function setBusy(busy) {
                isSpinning = busy;
                spinBtn.disabled = busy;
                pickBtn.disabled = busy;
                resetBtn.disabled = busy;
                if (saveItemsBtn) saveItemsBtn.disabled = busy;
                if (loadDefaultBtn) loadDefaultBtn.disabled = busy;
                if (itemsInput) itemsInput.disabled = busy;
                const centerSpinBtn = document.getElementById("centerSpinBtn");
                if (centerSpinBtn) {
                    centerSpinBtn.classList.toggle("disabled", busy);
                }

                if (availableItems.length <= 0) {
                    statusPill.textContent = "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                } else {
                    statusPill.textContent = busy ? "ƒêang quay..." : "S·∫µn s√†ng";
                }
            }

            // ===== Strip =====
            function renderStripByIndex(centerIdx, size = 9) {
                const n = Math.max(1, availableItems.length);
                const half = Math.floor(size / 2);

                const cells = [];
                for (let i = -half; i <= half; i++) {
                    let idx = centerIdx + i;
                    idx = ((idx % n) + n) % n;
                    const text = availableItems[idx] ?? "";
                    cells.push({ idx, text });
                }

                stripEl.innerHTML = cells.map((c, k) => {
                    const cls = k === half ? "cell active" : (k === 0 || k === size - 1 ? "cell edge" : "cell");
                    const short = shorten(c.text, 12);
                    return `<div class="${cls}" title="${escapeHtml(c.text)}">${escapeHtml(short)}</div>`;
                }).join("");
            }

            function indexToStopAngle(idx, total) {
                const span = Math.max(1, total);
                const slice = (Math.PI * 2) / span;

                const top = -Math.PI / 2;
                const marker = idx * slice + slice / 2;
                const jitter = (Math.random() - 0.5) * slice * 0.25;

                let target = top - marker + jitter;
                target = ((target % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                return target;
            }

            // ===== FIREWORKS =====
            const fx = $("fxCanvas");
            const fctx = fx.getContext("2d");
            let fxW = 0, fxH = 0;

            function resizeFx() {
                fxW = fx.width = Math.floor(window.innerWidth * devicePixelRatio);
                fxH = fx.height = Math.floor(window.innerHeight * devicePixelRatio);
            }
            window.addEventListener("resize", resizeFx);
            resizeFx();

            const sparks = [];
            let fxRunning = false;
            let fxRAF = 0;
            let burstTimer = 0;
            let stopTimer = 0;

            function addBurst(x, y, count = 120) {
                const px = x * devicePixelRatio;
                const py = y * devicePixelRatio;

                for (let i = 0; i < count; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const sp = 2 + Math.random() * 6;
                    const life = 45 + Math.random() * 45;

                    const palette = [
                        [255, 211, 106],
                        [255, 60, 60],
                        [255, 245, 230],
                        [255, 179, 0]
                    ];
                    const c = palette[(Math.random() * palette.length) | 0];

                    sparks.push({
                        x: px, y: py,
                        vx: Math.cos(a) * sp * devicePixelRatio,
                        vy: Math.sin(a) * sp * devicePixelRatio,
                        g: 0.12 * devicePixelRatio,
                        life, ttl: life,
                        r: 1.2 + Math.random() * 2.6,
                        c
                    });
                }
            }

            function shootBurstWave() {
                const bursts = 2 + ((Math.random() * 3) | 0);
                for (let i = 0; i < bursts; i++) {
                    const x = window.innerWidth * (0.18 + Math.random() * 0.64);
                    const y = window.innerHeight * (0.16 + Math.random() * 0.40);
                    addBurst(x, y, 90 + ((Math.random() * 90) | 0));
                }
            }

            function stopFireworks() {
                fxRunning = false;
                if (burstTimer) clearInterval(burstTimer);
                if (stopTimer) clearTimeout(stopTimer);
                burstTimer = 0;
                stopTimer = 0;
            }

            function startFireworks(seconds = 3.2) {
                stopFireworks();
                fxRunning = true;
                shootBurstWave();

                burstTimer = setInterval(shootBurstWave, 220);
                stopTimer = setTimeout(() => stopFireworks(), Math.floor(seconds * 1000));

                if (!fxRAF) fxRAF = requestAnimationFrame(fxFrame);
            }

            function fxFrame() {
                fctx.clearRect(0, 0, fxW, fxH);
                fctx.globalCompositeOperation = "lighter";

                for (let i = sparks.length - 1; i >= 0; i--) {
                    const s = sparks[i];
                    s.vy += s.g;
                    s.x += s.vx;
                    s.y += s.vy;
                    s.life -= 1;

                    const k = Math.max(0, s.life / s.ttl);
                    const alpha = 0.95 * k;

                    fctx.beginPath();
                    fctx.fillStyle = `rgba(${s.c[0]},${s.c[1]},${s.c[2]},${alpha})`;
                    fctx.arc(s.x, s.y, s.r * devicePixelRatio, 0, Math.PI * 2);
                    fctx.fill();

                    if (s.life <= 0) sparks.splice(i, 1);
                }

                if (sparks.length > 0 || fxRunning) {
                    fxRAF = requestAnimationFrame(fxFrame);
                } else {
                    fxRAF = 0;
                    fctx.clearRect(0, 0, fxW, fxH);
                }
            }

            function celebrate() {
                try { fireworkSound.currentTime = 0; fireworkSound.play().catch(() => { }); } catch { }
                startFireworks(3.2);
            }

            // ===== helpers =====
            function pickIndex() {
                if (availableItems.length <= 0) return null;
                return secureRandomInt(0, availableItems.length - 1);
            }

            function removePicked(pickedText) {
                const idx = availableItems.indexOf(pickedText);
                if (idx >= 0) {
                    availableItems.splice(idx, 1);
                    saveItems();
                }

                setTextareaFromList(availableItems);
                drawWheel();

                if (availableItems.length <= 0) {
                    statusPill.textContent = "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                    stripEl.innerHTML = "";
                } else {
                    statusPill.textContent = "S·∫µn s√†ng";
                }
            }

            // ===== Main actions =====
            function spin() {
                if (isSpinning) return;
                loadItems();

                if (availableItems.length <= 0) {
                    statusPill.textContent = "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                    return;
                }

                const idx = pickIndex();
                if (idx == null) return;

                const pickedText = availableItems[idx];

                const targetBase = indexToStopAngle(idx, availableItems.length);
                const extraTurns = secureRandomInt(5, 9);
                const target = targetBase + extraTurns * Math.PI * 2;

                setBusy(true);
                startSpinSound();

                centerNumber.textContent = "‚Ä¶";
                centerText.textContent = "ƒêang quay";

                const start = angle;
                const delta = target - start;

                const duration = 3600 + secureRandomInt(0, 900);
                const t0 = performance.now();

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                let rollIdx = secureRandomInt(0, availableItems.length - 1);

                function stripFrame(now) {
                    const t = (now - t0) / duration;
                    const clamped = Math.min(1, Math.max(0, t));
                    const e = easeOutCubic(clamped);

                    const step = Math.max(1, Math.floor(5 - 4 * e));
                    rollIdx = (rollIdx + step) % Math.max(1, availableItems.length);

                    const showIdx = (clamped < 0.98) ? rollIdx : idx;
                    renderStripByIndex(showIdx, 9);

                    if (clamped < 1) requestAnimationFrame(stripFrame);
                }
                requestAnimationFrame(stripFrame);

                function frame(now) {
                    const t = (now - t0) / duration;
                    const clamped = Math.min(1, Math.max(0, t));
                    const e = easeOutCubic(clamped);

                    angle = start + delta * e;
                    drawWheel();

                    if (clamped < 1) {
                        requestAnimationFrame(frame);
                    } else {
                        angle = targetBase;
                        drawWheel();

                        centerNumber.textContent = "8.3";
                        centerText.textContent = pickedText;
                        if (lastResult) lastResult.textContent = pickedText;

                        stopSpinSound();
                        playWinSound();
                        celebrate();

                        pushHistory(pickedText, "quay");
                        openResultModal(pickedText);

                        if (availableItems.length > 0) {
                            renderStripByIndex(secureRandomInt(0, availableItems.length - 1), 9);
                        }

                        setBusy(false);
                    }
                }
                requestAnimationFrame(frame);
            }

            function pickInstant() {
                if (isSpinning) return;
                loadItems();

                if (availableItems.length <= 0) {
                    statusPill.textContent = "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                    return;
                }

                const idx = pickIndex();
                if (idx == null) return;

                const pickedText = availableItems[idx];

                angle = indexToStopAngle(idx, availableItems.length);
                drawWheel();

                centerNumber.textContent = "8.3";
                centerText.textContent = pickedText;
                if (lastResult) lastResult.textContent = pickedText;

                renderStripByIndex(idx, 9);

                playWinSound();
                celebrate();

                pushHistory(pickedText, "b·ªëc");
                removePicked(pickedText);

                if (availableItems.length > 0) {
                    renderStripByIndex(secureRandomInt(0, availableItems.length - 1), 9);
                    statusPill.textContent = "S·∫µn s√†ng";
                } else {
                    statusPill.textContent = "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                }
            }

            function resetAll() {
                if (isSpinning) return;
                stopSpinSound();

                history = [];
                saveHistory();
                renderHistory();

                loadItems();
                if (!availableItems.length) {
                    availableItems = [...DEFAULT_ITEMS];
                    saveItems();
                }
                setTextareaFromList(availableItems);

                centerNumber.textContent = "‚Äî";
                centerText.textContent = "K·∫øt qu·∫£";
                if (lastResult) lastResult.textContent = "‚Äî";

                statusPill.textContent = availableItems.length ? "S·∫µn s√†ng" : "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                drawWheel();

                if (availableItems.length) {
                    renderStripByIndex(secureRandomInt(0, availableItems.length - 1), 9);
                } else {
                    stripEl.innerHTML = "";
                }
            }

            // ===== Items panel events =====
            if (loadDefaultBtn) {
                loadDefaultBtn.addEventListener("click", () => {
                    if (isSpinning) return;
                    availableItems = [...DEFAULT_ITEMS];
                    saveItems();
                    setTextareaFromList(availableItems);

                    statusPill.textContent = "S·∫µn s√†ng";
                    drawWheel();
                    renderStripByIndex(secureRandomInt(0, availableItems.length - 1), 9);
                });
            }

            if (saveItemsBtn) {
                saveItemsBtn.addEventListener("click", () => {
                    if (isSpinning) return;
                    if (!itemsInput) return;

                    const lines = itemsInput.value.split(/\r?\n/);
                    const items = normalizeItems(lines);

                    if (items.length === 0) {
                        alert("Danh s√°ch tr·ªëng. Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 d√≤ng.");
                        return;
                    }

                    availableItems = items;
                    saveItems();
                    setTextareaFromList(availableItems);

                    centerNumber.textContent = "‚Äî";
                    centerText.textContent = "K·∫øt qu·∫£";
                    statusPill.textContent = "S·∫µn s√†ng";

                    drawWheel();
                    renderStripByIndex(secureRandomInt(0, availableItems.length - 1), 9);

                    alert(`ƒê√£ l∆∞u ${items.length} m·ª•c.`);
                });
            }
            // Settings events
            if (settingsBtn) settingsBtn.addEventListener("click", openSettings);
            if (settingsCloseBtn) settingsCloseBtn.addEventListener("click", closeSettings);

            if (settingsModal) {
                settingsModal.addEventListener("click", (e) => {
                    const el = e.target;
                    if (el && el.getAttribute && el.getAttribute("data-close-settings") === "1") {
                        closeSettings();
                    }
                });
            }

            function onPrefsChanged() {
                const prefs = {
                    showStrip: !!toggleStrip?.checked,
                    showItems: !!toggleItems?.checked,
                };
                savePrefs(prefs);
                applyPrefs(prefs);
            }

            if (toggleStrip) toggleStrip.addEventListener("change", onPrefsChanged);
            if (toggleItems) toggleItems.addEventListener("change", onPrefsChanged);

            // cho ƒë·∫πp: click v√†o toggleWrap c≈©ng ƒë·ªïi
            if (toggleStripWrap) toggleStripWrap.addEventListener("click", () => {
                if (!toggleStrip) return;
                toggleStrip.checked = !toggleStrip.checked;
                onPrefsChanged();
            });
            if (toggleItemsWrap) toggleItemsWrap.addEventListener("click", () => {
                if (!toggleItems) return;
                toggleItems.checked = !toggleItems.checked;
                onPrefsChanged();
            });
            // ===== Button events =====
            spinBtn.addEventListener("click", spin);
            pickBtn.addEventListener("click", pickInstant);
            resetBtn.addEventListener("click", resetAll);

            // Modal events
            if (resultModal) {
                resultModal.addEventListener("click", (e) => {
                    const el = e.target;
                    if (el && el.getAttribute && el.getAttribute("data-close") === "1") {
                        closeResultModal();
                    }
                });
            }
            if (modalCloseBtn) modalCloseBtn.addEventListener("click", closeResultModal);

            if (modalRemoveBtn) {
                modalRemoveBtn.addEventListener("click", () => {
                    if (!pendingPickedText) return;
                    removePicked(pendingPickedText);
                    closeResultModal();
                });
            }

            window.addEventListener("keydown", (e) => {
                if (e.key === "Escape" && resultModal?.classList.contains("show")) {
                    closeResultModal();
                }
            });

            // ===== Init =====
            loadHistory();
            renderHistory();

            loadItems();
            drawWheel();
            applyPrefs(loadPrefs());
            if (availableItems.length) {
                renderStripByIndex(secureRandomInt(0, availableItems.length - 1), 9);
                statusPill.textContent = "S·∫µn s√†ng";
            } else {
                statusPill.textContent = "H·∫øt m·ª•c (b·∫•m RESET ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)";
                stripEl.innerHTML = "";
            }
            const centerSpinBtn = document.getElementById("centerSpinBtn");

            if (centerSpinBtn) {
                centerSpinBtn.addEventListener("click", () => {
                    const event = new Event("click");
                    document.getElementById("spinBtn").dispatchEvent(event);
                });
            }
        })();

    </script>
</body>

</html>