<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>V√≤ng xoay may m·∫Øn 1‚Äì1600</title>
    <style>
        :root {
            --bg: #0b1220;
            --muted: #9fb0d0;
            --text: #eaf0ff;
            --accent: #7c5cff;
            --accent2: #27d6a5;
            --danger: #ff4d6d;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(1200px 700px at 30% 20%, #18264b 0%, var(--bg) 55%, #050914 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .app {
            width: min(1100px, 100%);
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 18px;
        }

        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 18px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, .35);
            overflow: hidden;
        }

        .hd {
            padding: 16px 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.10);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .title {
            font-weight: 800;
            letter-spacing: .2px;
        }

        .sub {
            color: var(--muted);
            font-size: 13px;
            margin-top: 4px;
        }

        .bd {
            padding: 16px 18px;
        }

        .wheelWrap {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 0 18px;
        }

        canvas {
            width: min(560px, 92vw);
            height: auto;
            aspect-ratio: 1/1;
            border-radius: 999px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            box-shadow: inset 0 0 0 10px rgba(0, 0, 0, 0.25), 0 20px 50px rgba(0, 0, 0, 0.45);
        }

        .pointer {
            position: absolute;
            top: 6px;
            width: 0;
            height: 0;
            border-left: 18px solid transparent;
            border-right: 18px solid transparent;
            border-top: 34px solid var(--danger);
            filter: drop-shadow(0 6px 10px rgba(0, 0, 0, .35));
            z-index: 3;
        }

        .center {
            position: absolute;
            width: 130px;
            height: 130px;
            border-radius: 999px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.16);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            pointer-events: none;
            text-align: center;
            padding: 10px;
            z-index: 2;
        }

        .center .big {
            font-size: 24px;
            font-weight: 900;
            line-height: 1.1;
        }

        .center .small {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        .controls {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }

        .btn {
            appearance: none;
            border: none;
            cursor: pointer;
            padding: 12px 14px;
            border-radius: 12px;
            font-weight: 800;
            color: var(--text);
            background: linear-gradient(135deg, var(--accent), #4b86ff);
            box-shadow: 0 10px 24px rgba(124, 92, 255, .25);
            transition: transform .08s ease, filter .15s ease, opacity .15s ease;
            user-select: none;
            white-space: nowrap;
        }

        .btn:active {
            transform: translateY(1px) scale(.99);
        }

        .btn.secondary {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: none;
            font-weight: 750;
        }

        .btn.danger {
            background: linear-gradient(135deg, var(--danger), #ff8a5c);
            box-shadow: 0 10px 24px rgba(255, 77, 109, .18);
        }

        .btn:disabled {
            opacity: .55;
            cursor: not-allowed;
            filter: saturate(.7);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: var(--muted);
            font-size: 13px;
            white-space: nowrap;
        }

        label {
            color: var(--muted);
            font-size: 13px;
        }

        input[type="number"] {
            width: 120px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(0, 0, 0, 0.25);
            color: var(--text);
            outline: none;
        }

        .resultBox {
            display: grid;
            gap: 10px;
        }

        .result {
            padding: 14px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.18);
        }

        .result .k {
            color: var(--muted);
            font-size: 12px;
        }

        .result .v {
            font-size: 34px;
            font-weight: 950;
            margin-top: 2px;
        }

        .hint {
            color: var(--muted);
            font-size: 13px;
            line-height: 1.45;
        }

        .history {
            max-height: 360px;
            overflow: auto;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.14);
        }

        .history table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .history th,
        .history td {
            padding: 10px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            text-align: left;
            color: var(--text);
        }

        .history th {
            color: var(--muted);
            font-weight: 700;
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.22);
            backdrop-filter: blur(8px);
        }

        .history td.num {
            font-weight: 900;
        }

        .badge {
            display: inline-flex;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.14);
            background: rgba(255, 255, 255, 0.06);
            color: var(--muted);
            font-size: 12px;
        }

        .footerNote {
            margin-top: 10px;
            color: var(--muted);
            font-size: 12px;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
    </style>
</head>

<body>
    <div class="app">
        <!-- LEFT: WHEEL -->
        <div class="card">
            <div class="hd">
                <div>
                    <div class="title">V√≤ng xoay may m·∫Øn</div>
                    <div class="sub">Random s·ªë t·ª´ <span class="mono">1</span> ƒë·∫øn <span class="mono">1600</span></div>
                </div>
                <div class="pill" id="statusPill">S·∫µn s√†ng</div>
            </div>

            <div class="bd">
                <div class="wheelWrap">
                    <div class="pointer" aria-hidden="true"></div>
                    <canvas id="wheel" width="900" height="900"></canvas>
                    <div class="center">
                        <div class="big" id="centerNumber">‚Äî</div>
                        <div class="small" id="centerText">K·∫øt qu·∫£</div>
                    </div>
                </div>

                <div class="controls">
                    <div class="row">
                        <button class="btn" id="spinBtn">QUAY</button>
                        <button class="btn secondary" id="pickBtn">B·ªêC NG·∫™U NHI√äN (kh√¥ng quay)</button>
                    </div>

                    <div class="row">
                        <div class="pill">
                            <label for="min">Min</label>
                            <input id="min" type="number" value="1" min="1" max="1600" step="1" />
                            <span class="badge">‚Üî</span>
                            <label for="max">Max</label>
                            <input id="max" type="number" value="1600" min="1" max="1600" step="1" />
                        </div>
                        <button class="btn danger" id="resetBtn">RESET L·ªäCH S·ª¨</button>
                    </div>

                    <div class="hint">
                        - N√∫t <b>QUAY</b>: c√≥ animation gi·∫£m t·ªëc + d·ª´ng ƒë√∫ng s·ªë.<br />
                        - N√∫t <b>B·ªêC</b>: ra s·ªë ngay (kh√¥ng animation).<br />
                        - C√≥ l∆∞u l·ªãch s·ª≠ ·ªü b√™n ph·∫£i.
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT: RESULT + HISTORY -->
        <div class="card">
            <div class="hd">
                <div>
                    <div class="title">K·∫øt qu·∫£ & L·ªãch s·ª≠</div>
                    <div class="sub">M·ªói l·∫ßn quay/b·ªëc s·∫Ω l∆∞u l·∫°i</div>
                </div>
                <div class="pill"><span class="badge">T·ªïng</span> <span id="count">0</span></div>
            </div>

            <div class="bd resultBox">
                <div class="result">
                    <div class="k">K·∫øt qu·∫£ g·∫ßn nh·∫•t</div>
                    <div class="v" id="lastResult">‚Äî</div>
                    <!-- <div class="footerNote">Seed ng·∫´u nhi√™n: d√πng <span class="mono">crypto.getRandomValues</span> khi
                        c√≥.</div> -->
                </div>

                <div class="history" id="historyBox">
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>S·ªë</th>
                                <th>Ki·ªÉu</th>
                                <th>Th·ªùi gian</th>
                            </tr>
                        </thead>
                        <tbody id="historyBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        (() => {
            // ===== Helpers =====
            const $ = (id) => document.getElementById(id);

            function secureRandomInt(min, max) {
                // inclusive
                min = Math.ceil(min); max = Math.floor(max);
                if (max < min) [min, max] = [max, min];
                const range = max - min + 1;
                if (range <= 0) return min;

                // Prefer crypto
                if (window.crypto && crypto.getRandomValues) {
                    // Rejection sampling to avoid modulo bias
                    const maxUint = 0xFFFFFFFF;
                    const limit = Math.floor(maxUint / range) * range;
                    const buf = new Uint32Array(1);
                    let x;
                    do {
                        crypto.getRandomValues(buf);
                        x = buf[0];
                    } while (x >= limit);
                    return min + (x % range);
                }

                return min + Math.floor(Math.random() * range);
            }

            function fmtTime(d) {
                const pad = (n) => String(n).padStart(2, '0');
                return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
            }

            // ===== State =====
            const canvas = $("wheel");
            const ctx = canvas.getContext("2d");

            const spinBtn = $("spinBtn");
            const pickBtn = $("pickBtn");
            const resetBtn = $("resetBtn");

            const minEl = $("min");
            const maxEl = $("max");

            const statusPill = $("statusPill");
            const centerNumber = $("centerNumber");
            const centerText = $("centerText");
            const lastResult = $("lastResult");
            const historyBody = $("historyBody");
            const countEl = $("count");

            let isSpinning = false;

            // rotation state (radians)
            let angle = 0;

            // Visual wheel configuration:
            // We won't draw 1600 slices (too dense). We'll draw a nice "decor" wheel
            // and compute a selected number independently, then stop at the angle for that number.
            const DECOR_SLICES = 24;

            // wheel geometry
            const W = canvas.width, H = canvas.height;
            const cx = W / 2, cy = H / 2;
            const radius = Math.min(W, H) * 0.46;

            // ===== Storage =====
            const STORAGE_KEY = "lucky_wheel_history_v1";
            let history = [];
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (raw) history = JSON.parse(raw) || [];
            } catch { history = []; }

            function saveHistory() {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(history)); } catch { }
            }

            function pushHistory(num, type) {
                const item = { num, type, t: Date.now() };
                history.unshift(item);
                if (history.length > 200) history.length = 200; // cap
                saveHistory();
                renderHistory();
            }

            function renderHistory() {
                historyBody.innerHTML = history.map((h, idx) => {
                    const d = new Date(h.t);
                    return `
        <tr>
          <td>${history.length - idx}</td>
          <td class="num">${h.num}</td>
          <td><span class="badge">${h.type}</span></td>
          <td class="mono">${fmtTime(d)}</td>
        </tr>
      `;
                }).join("");
                countEl.textContent = String(history.length);
                lastResult.textContent = history[0]?.num ?? "‚Äî";
            }

            // ===== Wheel drawing =====
            function drawWheel() {
                ctx.clearRect(0, 0, W, H);

                // outer ring
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);

                for (let i = 0; i < DECOR_SLICES; i++) {
                    const a0 = (i / DECOR_SLICES) * Math.PI * 2;
                    const a1 = ((i + 1) / DECOR_SLICES) * Math.PI * 2;

                    // alternating fill (no hard-coded colors requirement doesn't exist here, but keep tasteful)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius, a0, a1);
                    ctx.closePath();

                    const alt = i % 2;
                    ctx.fillStyle = alt ? "rgba(124,92,255,0.35)" : "rgba(39,214,165,0.28)";
                    ctx.fill();

                    // separator
                    ctx.strokeStyle = "rgba(255,255,255,0.12)";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // label (1..24 just as decor)
                    const mid = (a0 + a1) / 2;
                    ctx.save();
                    ctx.rotate(mid);
                    ctx.translate(radius * 0.72, 0);
                    ctx.rotate(Math.PI / 2);
                    ctx.fillStyle = "rgba(255,255,255,0.85)";
                    ctx.font = "800 34px system-ui, sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(String(i + 1), 0, 0);
                    ctx.restore();
                }

                // inner ring
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.62, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(0,0,0,0.25)";
                ctx.fill();
                ctx.lineWidth = 6;
                ctx.strokeStyle = "rgba(255,255,255,0.10)";
                ctx.stroke();

                // highlight glare
                const grd = ctx.createRadialGradient(-radius * 0.25, -radius * 0.25, radius * 0.05, 0, 0, radius);
                grd.addColorStop(0, "rgba(255,255,255,0.20)");
                grd.addColorStop(0.45, "rgba(255,255,255,0.05)");
                grd.addColorStop(1, "rgba(255,255,255,0.00)");
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fillStyle = grd;
                ctx.fill();

                ctx.restore();

                // fixed center dot (visual)
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.06, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255,255,255,0.12)";
                ctx.fill();
            }

            // ===== Spin logic =====
            function setBusy(busy) {
                isSpinning = busy;
                spinBtn.disabled = busy;
                pickBtn.disabled = busy;
                minEl.disabled = busy;
                maxEl.disabled = busy;
                statusPill.textContent = busy ? "ƒêang quay..." : "S·∫µn s√†ng";
            }

            function clampRange() {
                let min = parseInt(minEl.value || "1", 10);
                let max = parseInt(maxEl.value || "1600", 10);
                if (!Number.isFinite(min)) min = 1;
                if (!Number.isFinite(max)) max = 1600;

                // constrain to 1..1600
                min = Math.max(1, Math.min(1600, min));
                max = Math.max(1, Math.min(1600, max));

                // keep inputs consistent
                minEl.value = String(min);
                maxEl.value = String(max);
                return { min, max };
            }

            function numberToStopAngle(num, min, max) {
                // Map num within [min,max] to an angle so that it lands at pointer (top).
                // We'll map it into a 0..2œÄ position based on normalized value.
                const span = (max - min + 1);
                const idx = (num - min); // 0..span-1
                const frac = span > 1 ? (idx / span) : 0;

                // pointer is at -90deg (top). In canvas rotation, 0 rad points to the right.
                // We'll choose a target such that wheel rotation brings "marker" to top.
                // Add a small random jitter inside the slice width (visual variety)
                const slice = (Math.PI * 2) / Math.max(span, 1);
                const jitter = (Math.random() - 0.5) * slice * 0.35;

                // position angle where that number's marker is at top:
                // marker angle in wheel local coords:
                const marker = frac * Math.PI * 2;
                const top = -Math.PI / 2;

                // We want: (angle + marker) == top  (mod 2œÄ)  => angle == top - marker
                let target = top - marker + jitter;

                // normalize
                target = ((target % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                return target;
            }

            function spin() {
                if (isSpinning) return;
                const { min, max } = clampRange();
                if (max < min) return;

                const picked = secureRandomInt(min, max);

                // Decide where to stop
                const targetBase = numberToStopAngle(picked, min, max);

                // Add several full rotations for drama
                const extraTurns = secureRandomInt(5, 9); // 5..9 turns
                const target = targetBase + extraTurns * Math.PI * 2;

                // Animation with ease-out
                setBusy(true);
                centerNumber.textContent = "‚Ä¶";
                centerText.textContent = "ƒêang quay";

                const start = angle;
                const delta = target - start;

                const duration = 3800 + secureRandomInt(0, 900); // ms
                const t0 = performance.now();

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

                function frame(now) {
                    const t = (now - t0) / duration;
                    const clamped = Math.min(1, Math.max(0, t));
                    const e = easeOutCubic(clamped);

                    angle = start + delta * e;
                    drawWheel();

                    if (clamped < 1) {
                        requestAnimationFrame(frame);
                    } else {
                        // final normalize for stability
                        angle = targetBase; // store modulo 2œÄ
                        drawWheel();

                        centerNumber.textContent = String(picked);
                        centerText.textContent = "Tr√∫ng th∆∞·ªüng üéâ";
                        lastResult.textContent = String(picked);

                        pushHistory(picked, "quay");
                        setBusy(false);
                    }
                }
                requestAnimationFrame(frame);
            }

            function pickInstant() {
                if (isSpinning) return;
                const { min, max } = clampRange();
                const picked = secureRandomInt(min, max);

                // Snap wheel near the number (optional quick rotate)
                const targetBase = numberToStopAngle(picked, min, max);
                angle = targetBase;
                drawWheel();

                centerNumber.textContent = String(picked);
                centerText.textContent = "B·ªëc ngay";
                lastResult.textContent = String(picked);
                pushHistory(picked, "b·ªëc");
            }

            function resetHistory() {
                if (isSpinning) return;
                history = [];
                saveHistory();
                renderHistory();
                centerNumber.textContent = "‚Äî";
                centerText.textContent = "K·∫øt qu·∫£";
                lastResult.textContent = "‚Äî";
            }

            // ===== Events =====
            spinBtn.addEventListener("click", spin);
            pickBtn.addEventListener("click", pickInstant);
            resetBtn.addEventListener("click", resetHistory);

            [minEl, maxEl].forEach(el => {
                el.addEventListener("change", () => clampRange());
                el.addEventListener("blur", () => clampRange());
            });

            // ===== Init =====
            clampRange();
            renderHistory();
            drawWheel();
        })();
    </script>
</body>

</html>